import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { logger } from '../src/utils/logger';
import { writeFileSync, unlinkSync, existsSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';
import { convertImageToBase64 } from '../src/utils/messageOperations';

describe('convertImageToBase64', () => {
  let tempImagePath: string;

  beforeEach(() => {
    // 创建一个临时的PNG图片文件用于测试
    // 这是一个1x1像素透明PNG的二进制数据
    const pngBuffer = Buffer.from([
      0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1f, 0x15, 0xc4, 0x89, 0x00, 0x00, 0x00, 0x0d, 0x49,
      0x44, 0x41, 0x54, 0x78, 0xda, 0x63, 0xfc, 0xcf, 0xc0, 0x50, 0x0f, 0x00, 0x04, 0x85, 0x01, 0x80, 0x84, 0xa9, 0x8c,
      0x21, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
    ]);

    tempImagePath = join(tmpdir(), `test-image-${Date.now()}.png`);
    writeFileSync(tempImagePath, pngBuffer);
  });

  afterEach(() => {
    // 清理临时文件
    if (existsSync(tempImagePath)) {
      try {
        unlinkSync(tempImagePath);
      } catch {
        logger.warn('Failed to cleanup temp file:', tempImagePath);
      }
    }
  });

  it('should convert PNG image to base64 data URL', () => {
    const result = convertImageToBase64(tempImagePath);

    expect(result).toMatch(/^data:image\/png;base64,/);
    expect(result.length).toBeGreaterThan('data:image/png;base64,'.length);
  });

  it('should handle JPEG files with correct MIME type', () => {
    const jpegPath = tempImagePath.replace('.png', '.jpg');
    // 复制文件并重命名为.jpg
    const pngBuffer = Buffer.from([
      0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1f, 0x15, 0xc4, 0x89, 0x00, 0x00, 0x00, 0x0d, 0x49,
      0x44, 0x41, 0x54, 0x78, 0xda, 0x63, 0xfc, 0xcf, 0xc0, 0x50, 0x0f, 0x00, 0x04, 0x85, 0x01, 0x80, 0x84, 0xa9, 0x8c,
      0x21, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
    ]);
    writeFileSync(jpegPath, pngBuffer);

    const result = convertImageToBase64(jpegPath);

    expect(result).toMatch(/^data:image\/jpeg;base64,/);

    // 清理临时JPEG文件
    if (existsSync(jpegPath)) {
      unlinkSync(jpegPath);
    }
  });

  it('should handle non-existent files gracefully', () => {
    const nonExistentPath = '/tmp/non-existent-image.png';

    const result = convertImageToBase64(nonExistentPath);

    // 应该返回空的base64占位符，而不是抛出错误
    expect(result).toBe('data:image/png;base64,');
  });

  it('should handle files with unknown extensions', () => {
    const unknownExtPath = tempImagePath.replace('.png', '.unknown');
    const pngBuffer = Buffer.from([
      0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1f, 0x15, 0xc4, 0x89, 0x00, 0x00, 0x00, 0x0d, 0x49,
      0x44, 0x41, 0x54, 0x78, 0xda, 0x63, 0xfc, 0xcf, 0xc0, 0x50, 0x0f, 0x00, 0x04, 0x85, 0x01, 0x80, 0x84, 0xa9, 0x8c,
      0x21, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82,
    ]);
    writeFileSync(unknownExtPath, pngBuffer);

    const result = convertImageToBase64(unknownExtPath);

    // 应该默认使用PNG MIME类型
    expect(result).toMatch(/^data:image\/png;base64,/);

    // 清理临时文件
    if (existsSync(unknownExtPath)) {
      unlinkSync(unknownExtPath);
    }
  });
});
