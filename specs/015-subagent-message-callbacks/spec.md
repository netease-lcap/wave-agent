# Feature Specification: Subagent Message Callbacks

**Feature Branch**: `015-subagent-message-callbacks`  
**Created**: 2025-11-20  
**Status**: Completed  
**Input**: User description: "subagent messages callback is full messages, i want to add user added assistant added content updated tool updated callbacks for subagent"

## Implementation Summary

This feature has been successfully implemented through an architectural refactoring that moved subagent-specific callbacks from `MessageManager` to `SubagentManager`, creating a cleaner separation of concerns.

### Key Changes Made

1. **Created SubagentManagerCallbacks Interface**: New interface specifically for subagent events:
   - `onSubagentUserMessageAdded`
   - `onSubagentAssistantMessageAdded` 
   - `onSubagentAssistantContentUpdated`
   - `onSubagentToolBlockUpdated`
   - `onSubagentMessagesChange` (added for message state management)

2. **Refactored SubagentManager**: 
   - Removed `parentCallbacks` property in favor of `callbacks: SubagentManagerCallbacks`
   - Updated `createInstance` method to forward callbacks through the new system
   - Each subagent now properly forwards events with `subagentId` parameter
   - Messages removed from `SubagentBlock` type, handled via callbacks instead

3. **Removed Messages from SubagentBlock**:
   - `SubagentBlock` interface no longer contains `messages` field
   - `updateSubagentBlock` function no longer accepts `messages` parameter
   - Subagent messages now managed through dedicated callback system

4. **Updated UI Layer**:
   - `useChat` context now maintains `subagentMessages` state via callbacks
   - `SubagentBlock` component reads messages from context instead of block properties
   - Cleaner separation between message storage and UI display
   - `AgentCallbacks` now extends `SubagentManagerCallbacks`
   - Agent instantiation updated to pass callbacks to SubagentManager correctly

6. **Updated Test Suite**:
   - Removed obsolete tests from MessageManager for subagent callbacks
   - Updated SubagentManager tests to reflect new callback ownership
   - All 669 unit tests pass, confirming functionality

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Granular Subagent User Message Events (Priority: P1)

Developers need to track when subagents add user messages separately from the full message change events to implement real-time chat UIs that can show typing indicators and streaming updates at the subagent level.

**Why this priority**: This is the foundation for all other callbacks and is essential for proper UI state management in multi-agent scenarios. Without this, developers cannot distinguish between subagent activity types.

**Independent Test**: Can be fully tested by creating a subagent, sending it a message, and verifying the callback receives the user message parameters while delivering immediate value for debugging subagent interactions.

**Acceptance Scenarios**:

1. **Given** a subagent instance exists, **When** the subagent adds a user message, **Then** the parent receives an onSubagentUserMessageAdded callback with subagent ID and message parameters
2. **Given** multiple subagents are active, **When** one subagent adds a user message, **Then** only that subagent's callback is triggered with the correct subagent ID

---

### User Story 2 - Granular Subagent Assistant Message Events (Priority: P1)

Developers need to detect when subagents start generating assistant responses separately from content updates to implement proper loading states and response handling in multi-agent UIs.

**Why this priority**: Essential companion to user message callbacks for complete message lifecycle tracking. Provides immediate value for implementing loading states.

**Independent Test**: Can be tested by triggering a subagent AI response and verifying the callback is fired when the assistant message is created, before any content streaming begins.

**Acceptance Scenarios**:

1. **Given** a subagent receives a user message, **When** the AI manager creates an assistant message, **Then** the parent receives onSubagentAssistantMessageAdded callback with subagent ID
2. **Given** a subagent generates multiple assistant messages, **When** each message is added, **Then** separate callbacks are triggered for each message creation

---

### User Story 3 - Granular Subagent Content Streaming (Priority: P2)

Developers need real-time streaming updates for subagent assistant content to implement live text streaming in chat interfaces, showing content as it's generated by each subagent independently.

**Why this priority**: Provides enhanced UX through real-time feedback but is not essential for basic functionality. Builds on P1 features.

**Independent Test**: Can be tested by triggering subagent AI streaming response and verifying callbacks receive both chunks and accumulated content with subagent ID.

**Acceptance Scenarios**:

1. **Given** a subagent is streaming content, **When** new content chunks arrive, **Then** the parent receives onSubagentContentUpdated callbacks with subagent ID, chunk, and accumulated content
2. **Given** multiple subagents are streaming simultaneously, **When** content updates occur, **Then** each callback includes the correct subagent ID to distinguish sources

---

### User Story 4 - Granular Subagent Tool Usage Tracking (Priority: P2)

Developers need to monitor when subagents use tools to implement detailed activity monitoring and debugging capabilities, showing which tools each subagent is executing in real-time.

**Why this priority**: Important for debugging and monitoring but not essential for basic multi-agent functionality. Provides detailed insight into subagent behavior.

**Independent Test**: Can be tested by having a subagent execute a tool and verifying the callback receives tool update parameters with subagent ID.

**Acceptance Scenarios**:

1. **Given** a subagent executes a tool, **When** tool parameters or results update, **Then** the parent receives onSubagentToolUpdated callback with subagent ID and tool details
2. **Given** multiple subagents use tools concurrently, **When** tool updates occur, **Then** callbacks correctly identify which subagent triggered each tool update

---

### Edge Cases

- What happens when a subagent callback is registered after the subagent has already started processing?
- How does the system handle callback errors during subagent message processing?
- What occurs when a subagent is aborted mid-stream while content callbacks are active?
- How are callbacks handled when subagent instances are cleaned up?

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: System MUST provide onSubagentUserMessageAdded callback with subagent ID and user message parameters
- **FR-002**: System MUST provide onSubagentAssistantMessageAdded callback with subagent ID when assistant messages are created
- **FR-003**: System MUST provide onSubagentContentUpdated callback with subagent ID, content chunks, and accumulated content during streaming
- **FR-004**: System MUST provide onSubagentToolUpdated callback with subagent ID and tool update parameters
- **FR-005**: All subagent callbacks MUST include the subagent ID to distinguish between multiple active subagents
- **FR-006**: Subagent callbacks MUST be triggered in addition to (not instead of) existing full message change callbacks
- **FR-007**: System MUST handle callback registration both before and after subagent creation
- **FR-008**: Callbacks MUST be properly cleaned up when subagent instances are destroyed

### Key Entities *(include if feature involves data)*

- **SubagentManagerCallbacks**: New callback interface containing granular subagent-specific event handlers (separate from MessageManagerCallbacks)
- **SubagentMessageEvents**: Event parameters that include subagent ID and relevant message/content data  
- **SubagentManager**: Component responsible for forwarding subagent events to parent callback handlers through its own callback system
- **AgentCallbacks**: Extended to include SubagentManagerCallbacks for end-to-end callback support