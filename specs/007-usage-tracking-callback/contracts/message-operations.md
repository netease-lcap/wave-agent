# Message Operations Contract

**Version**: 1.0.0  
**Date**: 2025-11-11  

## Usage Data Integration with Message Operations

### Message Creation with Usage Data
Extension of existing message operations to support usage metadata.

```typescript
// Enhanced function signature for adding assistant messages
function addAssistantMessageToMessages(
  messages: Message[],
  content?: string,
  toolCalls?: ChatCompletionMessageToolCall[],
  usage?: Usage  // New optional parameter
): Message[]
```

**Parameters**:
- `usage`: Optional Usage object to embed in the assistant message
- Only provided for messages generated by AI operations
- Null/undefined for messages not involving AI service consumption

### Usage Data Embedding Rules
Usage data embedded according to operation type:

1. **Agent Call Messages**
   ```typescript
   const usage: Usage = {
     prompt_tokens: response.usage.prompt_tokens,
     completion_tokens: response.usage.completion_tokens, 
     total_tokens: response.usage.total_tokens,
     model: modelUsed,           // From agent configuration or override
     operation_type: 'agent'
   };
   ```

2. **Compression Messages**
   ```typescript
   const usage: Usage = {
     prompt_tokens: compressionResponse.usage.prompt_tokens,
     completion_tokens: compressionResponse.usage.completion_tokens,
     total_tokens: compressionResponse.usage.total_tokens, 
     model: fastModelUsed,       // From fast model configuration
     operation_type: 'compress'
   };
   ```

### Message Retrieval Operations
Existing message retrieval operations return enhanced messages:

```typescript
// Existing function - no signature change needed
function getMessages(): Message[] {
  // Returns messages with usage data intact
}
```

**Behavior**:
- Messages loaded from session include usage data if present
- Usage data preserved during message operations (updates, filtering)
- No breaking changes to existing message retrieval APIs

## Agent Usage Array Integration

### Direct Usage Storage
Agent class maintains usage array that gets updated when messages are created:

```typescript
class Agent {
  private _usages: Usage[] = [];
  
  private addUsage(usage: Usage): void {
    this._usages.push(usage);
  }
  
  public get usages(): Usage[] {
    return [...this._usages];  // Return copy
  }
}
```

**Integration with Message Operations**:
1. Message created with usage data
2. Usage data simultaneously pushed to Agent._usages array
3. Both message and usage array updated atomically
4. No aggregation or calculation required

### CLI Summary Calculation
Aggregation for CLI display calculated from Agent usage array:

```typescript
function calculateTokenSummary(usages: Usage[]): Map<string, TokenSummary> {
  const summaryMap = new Map<string, TokenSummary>();
  
  usages.forEach(usage => {
    const model = usage.model || 'unknown';
    
    if (!summaryMap.has(model)) {
      summaryMap.set(model, {
        model,
        prompt_tokens: 0,
        completion_tokens: 0,
        total_tokens: 0,
        operations: { agent_calls: 0, compressions: 0 }
      });
    }
    
    const summary = summaryMap.get(model)!;
    summary.prompt_tokens += usage.prompt_tokens;
    summary.completion_tokens += usage.completion_tokens;
    summary.total_tokens += usage.total_tokens;
    
    if (usage.operation_type === 'agent') {
      summary.operations.agent_calls++;
    } else if (usage.operation_type === 'compress') {
      summary.operations.compressions++;
    }
  });
  
  return summaryMap;
}
```

## Session Persistence Integration

### Save Operation Enhancement
Session save operations automatically include usage data:

```typescript
// Existing session save - no changes needed
async function saveSession(
  sessionId: string,
  messages: Message[],  // Messages now include usage data
  workdir: string,
  latestTotalTokens: number,
  sessionStartTime: string
): Promise<void>
```

**Behavior**:
- Usage data serialized as part of message JSON
- No additional save operations required
- Backwards compatible with sessions without usage data

### Load Operation Enhancement  
Session load operations restore usage data:

```typescript
// Existing session load - no changes needed
async function loadSession(sessionId: string): Promise<SessionData | null>
```

**Behavior**:
- Usage data deserialized from message JSON if present
- Agent._usages array rebuilt from message usage data during session load
- Missing usage fields treated as undefined (graceful degradation)
- No migration required for existing session files

## Error Handling Contract

### Invalid Usage Data Handling
Operations must handle corrupted or invalid usage data:

```typescript
function isValidUsage(usage: any): usage is Usage {
  return usage &&
    typeof usage.prompt_tokens === 'number' &&
    typeof usage.completion_tokens === 'number' &&
    typeof usage.total_tokens === 'number' &&
    usage.prompt_tokens >= 0 &&
    usage.completion_tokens >= 0 &&
    usage.total_tokens === usage.prompt_tokens + usage.completion_tokens;
}

function safeRestoreUsages(messages: Message[]): Usage[] {
  try {
    return messages
      .filter(m => m.role === 'assistant' && m.usage && isValidUsage(m.usage))
      .map(m => m.usage!);
  } catch (error) {
    console.warn('Usage restoration failed, returning empty array:', error);
    return [];
  }
}
```

### Missing Usage Data Handling
Operations gracefully handle messages without usage data:

- Messages without usage field are skipped during array restoration
- Empty usage arrays returned for sessions with no AI operations
- CLI summary displays "No usage data" message when appropriate

## Performance Considerations

### Direct Array Performance
Usage data access optimized through direct array storage:

- O(1) access time for Agent.usages getter
- O(1) append operation for new usage data
- No scanning or calculation overhead
- Direct array copy for external access

### Memory Impact
Usage data storage with dual storage approach:

- ~100-150 bytes per usage entry in Agent._usages array
- Additional ~100-150 bytes per message with usage data  
- Dual storage ensures persistence and fast access
- Memory overhead scales with number of AI operations

### CLI Display Performance  
Exit summary generation bounded for responsiveness:

- Maximum 500ms timeout for summary calculation and display
- Async generation to avoid blocking exit process
- Graceful fallback if summary generation fails