# Research: Markdown Rendering System

**Branch**: `020-markdown-rendering-system` | **Date**: 2024-12-01  
**Purpose**: Research technical approaches for rendering Markdown in an Ink-based terminal UI.

## Research Areas

### 1. Markdown Parsing Library

**Decision**: Use `marked` library.  
**Rationale**: 
- Highly popular, well-maintained, and fast.
- Provides a lexer that returns a structured token list, which is ideal for mapping to React/Ink components.
- Supports GFM (GitHub Flavored Markdown), including tables and task lists.

**Alternatives considered**:
- `markdown-it`: Also excellent, but `marked`'s lexer API is very straightforward for this use case.
- `remark`: Part of a larger ecosystem (unified), might be overkill for simple terminal rendering.

### 2. Rendering Strategy

**Decision**: Custom Ink-based renderer mapping tokens to components.  
**Rationale**: 
- Standard markdown-to-html renderers won't work in the terminal.
- Mapping tokens to Ink's `Box` and `Text` components allows for fine-grained control over terminal-specific styling (colors, bold, borders).
- Allows for custom logic like responsive table scaling.

### 3. Table Rendering in Terminal

**Decision**: Proportional scaling based on terminal width.  
**Rationale**: 
- Terminals have fixed widths.
- Tables often contain long strings that would otherwise wrap and break the table structure.
- By calculating the maximum content width per column and then scaling down if the total exceeds `process.stdout.columns`, we can maintain a readable table layout.

### 4. Handling HTML Entities

**Decision**: Manual unescaping of common entities.  
**Rationale**: 
- `marked` sometimes escapes characters like `<`, `>`, and `&` in its output.
- Since we are rendering to a terminal and not a browser, we need to convert these back to their literal characters for correct display.

## Integration Strategy

### Component Structure

- `Markdown`: Main component, uses `useMemo` to lex the input string once.
- `BlockRenderer`: Recursive component that switches on token type for block elements.
- `InlineRenderer`: Recursive component for inline elements, often used within `Text` components.
- `TableRenderer`: Handles the complex logic of width calculation and border rendering.

### Performance Considerations

- Use `React.memo` for the `Markdown` component to avoid unnecessary re-lexing and re-rendering when props haven't changed.
- Use `useMemo` for token generation and table width calculations.

## Performance Expectations

- **Lexing**: < 5ms for typical agent responses (a few KB of text).
- **Rendering**: Should be instantaneous for the user, even with complex structures like nested lists and tables.
- **Memory**: Minimal overhead, primarily the token list generated by `marked`.
